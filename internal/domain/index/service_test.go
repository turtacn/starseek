package index_test

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"sync"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"go.uber.org/zap" // 用于 MockLogger

	ferrors "github.com/turtacn/starseek/internal/common/errors"
	"github.com/turtacn/starseek/internal/domain/enum"
	"github.com/turtacn/starseek/internal/domain/index"          // 被测试的 domain/index 包
	"github.com/turtacn/starseek/internal/infrastructure/logger" // Mock Logger
)

// MockLogger 是一个用于测试的简单 Logger 实现
type MockLogger struct {
	Logs []string
	sync.Mutex
}

func (m *MockLogger) Debug(msg string, fields ...zap.Field) {
	m.Lock()
	defer m.Unlock()
	m.Logs = append(m.Logs, fmt.Sprintf("DEBUG: %s %v", msg, fields))
}
func (m *MockLogger) Info(msg string, fields ...zap.Field) {
	m.Lock()
	defer m.Unlock()
	m.Logs = append(m.Logs, fmt.Sprintf("INFO: %s %v", msg, fields))
}
func (m *MockLogger) Warn(msg string, fields ...zap.Field) {
	m.Lock()
	defer m.Unlock()
	m.Logs = append(m.Logs, fmt.Sprintf("WARN: %s %v", msg, fields))
}
func (m *MockLogger) Error(msg string, fields ...zap.Field) {
	m.Lock()
	defer m.Unlock()
	m.Logs = append(m.Logs, fmt.Sprintf("ERROR: %s %v", msg, fields))
}
func (m *MockLogger) Fatal(msg string, fields ...zap.Field) {
	m.Lock()
	defer m.Unlock()
	m.Logs = append(m.Logs, fmt.Sprintf("FATAL: %s %v", msg, fields))
	panic("Fatal called in test")
}

func (m *MockLogger) WithContext(ctx context.Context) logger.Logger { return m }
func (m *MockLogger) With(fields ...zap.Field) logger.Logger        { return m }

func NewMockLogger() *MockLogger {
	return &MockLogger{Logs: make([]string, 0)}
}

// InMemoryIndexMetadataRepository 是 IndexMetadataRepository 的一个内存实现，用于测试。
type InMemoryIndexMetadataRepository struct {
	mock.Mock
	mu    sync.RWMutex
	store map[string]*index.IndexMetadata // Key: ID
	tcMap map[string]string               // Key: TableName|ColumnName, Value: ID
}

func NewInMemoryIndexMetadataRepository() *InMemoryIndexMetadataRepository {
	return &InMemoryIndexMetadataRepository{
		store: make(map[string]*index.IndexMetadata),
		tcMap: make(map[string]string),
	}
}

func (r *InMemoryIndexMetadataRepository) Save(ctx context.Context, metadata *index.IndexMetadata) error {
	args := r.Called(ctx, metadata)
	if args.Error(0) != nil {
		return args.Error(0)
	}

	r.mu.Lock()
	defer r.mu.Unlock()

	// Simulate ID generation for new records
	if metadata.ID == "" {
		// In real repo, this would be handled by DB or UUID generation in service.
		// For in-memory, we assume ID is generated by the service before calling Save.
		// If service is to generate ID, we should remove this line.
		// For now, let's assume service generates ID.
	}

	r.store[metadata.ID] = metadata
	r.tcMap[fmt.Sprintf("%s|%s", metadata.TableName, metadata.ColumnName)] = metadata.ID
	return nil
}

func (r *InMemoryIndexMetadataRepository) FindByID(ctx context.Context, id string) (*index.IndexMetadata, error) {
	args := r.Called(ctx, id)
	if args.Get(0) != nil {
		return args.Get(0).(*index.IndexMetadata), args.Error(1)
	}
	return nil, args.Error(1)
}

func (r *InMemoryIndexMetadataRepository) FindByTableColumn(ctx context.Context, tableName, columnName string) (*index.IndexMetadata, error) {
	args := r.Called(ctx, tableName, columnName)
	if args.Get(0) != nil {
		return args.Get(0).(*index.IndexMetadata), args.Error(1)
	}
	return nil, args.Error(1)
}

func (r *InMemoryIndexMetadataRepository) ListAll(ctx context.Context) ([]*index.IndexMetadata, error) {
	args := r.Called(ctx)
	if args.Get(0) != nil {
		return args.Get(0).([]*index.IndexMetadata), args.Error(1)
	}
	return nil, args.Error(1)
}

func (r *InMemoryIndexMetadataRepository) ListByIndexedColumns(ctx context.Context, tableNames []string, columnNames []string) ([]*index.IndexMetadata, error) {
	args := r.Called(ctx, tableNames, columnNames)
	if args.Get(0) != nil {
		return args.Get(0).([]*index.IndexMetadata), args.Error(1)
	}
	return nil, args.Error(1)
}

func (r *InMemoryIndexMetadataRepository) DeleteByID(ctx context.Context, id string) error {
	args := r.Called(ctx, id)
	return args.Error(0)
}

func (r *InMemoryIndexMetadataRepository) Close(ctx context.Context) error {
	args := r.Called(ctx)
	return args.Error(0)
}

// --- Test Cases for IndexService ---

func TestRegisterIndex(t *testing.T) {
	ctx := context.Background()
	mockRepo := NewInMemoryIndexMetadataRepository()
	mockLog := NewMockLogger()
	svc := index.NewIndexService(mockRepo, mockLog)

	cmd := index.RegisterIndexCommand{
		TableName:   "users",
		ColumnName:  "email",
		IndexType:   enum.IndexTypeFullText,
		Tokenizer:   "standard",
		DataType:    "TEXT",
		Description: "Full-text index on user emails",
	}

	// Mock expectations for FindByTableColumn (initially not found)
	mockRepo.On("FindByTableColumn", ctx, cmd.TableName, cmd.ColumnName).Return(nil, ferrors.NewNotFoundError("not found", nil)).Once()
	// Mock expectations for Save
	mockRepo.On("Save", ctx, mock.AnythingOfType("*index.IndexMetadata")).Return(nil).Once()

	err := svc.RegisterIndex(ctx, cmd)
	assert.NoError(t, err)
	assert.Contains(t, mockLog.Logs[len(mockLog.Logs)-1], "INFO: Successfully registered index")

	mockRepo.AssertExpectations(t)
}

func TestRegisterIndex_AlreadyExists(t *testing.T) {
	ctx := context.Background()
	mockRepo := NewInMemoryIndexMetadataRepository()
	mockLog := NewMockLogger()
	svc := index.NewIndexService(mockRepo, mockLog)

	existingMetadata := &index.IndexMetadata{
		ID:         "some-uuid",
		TableName:  "products",
		ColumnName: "name",
		IndexType:  enum.IndexTypeFullText,
		CreatedAt:  time.Now(),
		UpdatedAt:  time.Now(),
	}

	cmd := index.RegisterIndexCommand{
		TableName:   "products",
		ColumnName:  "name",
		IndexType:   enum.IndexTypeFullText,
		Tokenizer:   "standard",
		DataType:    "VARCHAR",
		Description: "Full-text index on product names",
	}

	// Mock expectations for FindByTableColumn (found)
	mockRepo.On("FindByTableColumn", ctx, cmd.TableName, cmd.ColumnName).Return(existingMetadata, nil).Once()

	err := svc.RegisterIndex(ctx, cmd)
	assert.Error(t, err)
	appErr, ok := err.(*ferrors.AppError)
	require.True(t, ok)
	assert.Equal(t, ferrors.ErrCodeAlreadyExists, appErr.Code)
	assert.Contains(t, appErr.Message, "index for table products, column name already exists")
	assert.Contains(t, mockLog.Logs[len(mockLog.Logs)-1], "WARN: Index for products.name already exists")

	mockRepo.AssertExpectations(t)
	mockRepo.AssertNotCalled(t, "Save", ctx, mock.Anything) // Save should not be called
}

func TestRegisterIndex_RepoErrorOnCheck(t *testing.T) {
	ctx := context.Background()
	mockRepo := NewInMemoryIndexMetadataRepository()
	mockLog := NewMockLogger()
	svc := index.NewIndexService(mockRepo, mockLog)

	cmd := index.RegisterIndexCommand{
		TableName:  "orders",
		ColumnName: "item",
		IndexType:  enum.IndexTypeBTree,
		DataType:   "INT",
	}

	repoErr := errors.New("database connection lost")
	// Mock expectations for FindByTableColumn (returns a generic error)
	mockRepo.On("FindByTableColumn", ctx, cmd.TableName, cmd.ColumnName).Return(nil, repoErr).Once()

	err := svc.RegisterIndex(ctx, cmd)
	assert.Error(t, err)
	appErr, ok := err.(*ferrors.AppError)
	require.True(t, ok)
	assert.Equal(t, ferrors.ErrCodeInternalError, appErr.Code)
	assert.Contains(t, appErr.Message, "failed to check existing index")
	assert.Equal(t, repoErr, appErr.Unwrap())
	assert.Contains(t, mockLog.Logs[len(mockLog.Logs)-1], "ERROR: Failed to check existing index")

	mockRepo.AssertExpectations(t)
	mockRepo.AssertNotCalled(t, "Save", ctx, mock.Anything)
}

func TestRegisterIndex_RepoErrorOnSave(t *testing.T) {
	ctx := context.Background()
	mockRepo := NewInMemoryIndexMetadataRepository()
	mockLog := NewMockLogger()
	svc := index.NewIndexService(mockRepo, mockLog)

	cmd := index.RegisterIndexCommand{
		TableName:  "articles",
		ColumnName: "content",
		IndexType:  enum.IndexTypeFullText,
		DataType:   "TEXT",
	}

	repoErr := errors.New("failed to write to DB")
	mockRepo.On("FindByTableColumn", ctx, cmd.TableName, cmd.ColumnName).Return(nil, ferrors.NewNotFoundError("not found", nil)).Once()
	mockRepo.On("Save", ctx, mock.AnythingOfType("*index.IndexMetadata")).Return(repoErr).Once()

	err := svc.RegisterIndex(ctx, cmd)
	assert.Error(t, err)
	appErr, ok := err.(*ferrors.AppError)
	require.True(t, ok)
	assert.Equal(t, ferrors.ErrCodeInternalError, appErr.Code)
	assert.Contains(t, appErr.Message, "failed to save index metadata")
	assert.Equal(t, repoErr, appErr.Unwrap())
	assert.Contains(t, mockLog.Logs[len(mockLog.Logs)-1], "ERROR: Failed to save new index metadata")

	mockRepo.AssertExpectations(t)
}

func TestGetIndexByTableColumn_Found(t *testing.T) {
	ctx := context.Background()
	mockRepo := NewInMemoryIndexMetadataRepository()
	mockLog := NewMockLogger()
	svc := index.NewIndexService(mockRepo, mockLog)

	expectedMetadata := &index.IndexMetadata{
		ID:         "idx-123",
		TableName:  "posts",
		ColumnName: "title",
		IndexType:  enum.IndexTypeFullText,
		CreatedAt:  time.Now(),
		UpdatedAt:  time.Now(),
	}

	mockRepo.On("FindByTableColumn", ctx, "posts", "title").Return(expectedMetadata, nil).Once()

	retrievedMetadata, err := svc.GetIndexByTableColumn(ctx, "posts", "title")
	assert.NoError(t, err)
	assert.Equal(t, expectedMetadata, retrievedMetadata)
	assert.Contains(t, mockLog.Logs[len(mockLog.Logs)-1], "DEBUG: Successfully fetched index")

	mockRepo.AssertExpectations(t)
}

func TestGetIndexByTableColumn_NotFound(t *testing.T) {
	ctx := context.Background()
	mockRepo := NewInMemoryIndexMetadataRepository()
	mockLog := NewMockLogger()
	svc := index.NewIndexService(mockRepo, mockLog)

	mockRepo.On("FindByTableColumn", ctx, "nonexistent_table", "nonexistent_column").Return(nil, ferrors.NewNotFoundError("not found", nil)).Once()

	retrievedMetadata, err := svc.GetIndexByTableColumn(ctx, "nonexistent_table", "nonexistent_column")
	assert.Error(t, err)
	assert.Nil(t, retrievedMetadata)
	appErr, ok := err.(*ferrors.AppError)
	require.True(t, ok)
	assert.Equal(t, ferrors.ErrCodeNotFound, appErr.Code)
	assert.Contains(t, appErr.Message, "index for table nonexistent_table, column nonexistent_column not found")
	assert.Contains(t, mockLog.Logs[len(mockLog.Logs)-1], "INFO: Index for nonexistent_table.nonexistent_column not found")

	mockRepo.AssertExpectations(t)
}

func TestListIndexes(t *testing.T) {
	ctx := context.Background()
	mockRepo := NewInMemoryIndexMetadataRepository()
	mockLog := NewMockLogger()
	svc := index.NewIndexService(mockRepo, mockLog)

	idx1 := &index.IndexMetadata{ID: "idx1", TableName: "users", ColumnName: "name", IndexType: enum.IndexTypeFullText}
	idx2 := &index.IndexMetadata{ID: "idx2", TableName: "users", ColumnName: "email", IndexType: enum.IndexTypeFullText}
	idx3 := &index.IndexMetadata{ID: "idx3", TableName: "products", ColumnName: "price", IndexType: enum.IndexTypeBTree}
	idx4 := &index.IndexMetadata{ID: "idx4", TableName: "articles", ColumnName: "title", IndexType: enum.IndexTypeFullText}
	allIndexes := []*index.IndexMetadata{idx1, idx2, idx3, idx4}

	mockRepo.On("ListAll", ctx).Return(allIndexes, nil).Once() // Mock ListAll

	// Test 1: No filters, default pagination
	query := index.ListIndexesQuery{}
	result, err := svc.ListIndexes(ctx, query)
	assert.NoError(t, err)
	assert.Len(t, result, 4) // All 4 indexes should be returned by default limit (10)
	assert.ElementsMatch(t, allIndexes, result)

	// Test 2: Filter by TableName
	query = index.ListIndexesQuery{TableName: "users"}
	result, err = svc.ListIndexes(ctx, query)
	assert.NoError(t, err)
	assert.Len(t, result, 2)
	assert.Contains(t, result, idx1)
	assert.Contains(t, result, idx2)

	// Test 3: Filter by IndexType
	query = index.ListIndexesQuery{IndexType: enum.IndexTypeFullText}
	result, err = svc.ListIndexes(ctx, query)
	assert.NoError(t, err)
	assert.Len(t, result, 3)
	assert.Contains(t, result, idx1)
	assert.Contains(t, result, idx2)
	assert.Contains(t, result, idx4)

	// Test 4: Filter by TableName and ColumnName
	query = index.ListIndexesQuery{TableName: "users", ColumnName: "email"}
	result, err = svc.ListIndexes(ctx, query)
	assert.NoError(t, err)
	assert.Len(t, result, 1)
	assert.Contains(t, result, idx2)

	// Test 5: Pagination - Limit
	query = index.ListIndexesQuery{Limit: 2}
	result, err = svc.ListIndexes(ctx, query)
	assert.NoError(t, err)
	assert.Len(t, result, 2)

	// Test 6: Pagination - Offset
	query = index.ListIndexesQuery{Offset: 2, Limit: 2}
	result, err = svc.ListIndexes(ctx, query)
	assert.NoError(t, err)
	assert.Len(t, result, 2)

	mockRepo.AssertExpectations(t)
}

func TestDeleteIndexByID(t *testing.T) {
	ctx := context.Background()
	mockRepo := NewInMemoryIndexMetadataRepository()
	mockLog := NewMockLogger()
	svc := index.NewIndexService(mockRepo, mockLog)

	indexID := "index-to-delete-123"

	mockRepo.On("DeleteByID", ctx, indexID).Return(nil).Once()

	err := svc.DeleteIndexByID(ctx, indexID)
	assert.NoError(t, err)
	assert.Contains(t, mockLog.Logs[len(mockLog.Logs)-1], "INFO: Successfully deleted index with ID")

	mockRepo.AssertExpectations(t)
}

func TestDeleteIndexByID_RepoError(t *testing.T) {
	ctx := context.Background()
	mockRepo := NewInMemoryIndexMetadataRepository()
	mockLog := NewMockLogger()
	svc := index.NewIndexService(mockRepo, mockLog)

	indexID := "index-to-delete-456"
	repoErr := errors.New("db error on delete")

	mockRepo.On("DeleteByID", ctx, indexID).Return(repoErr).Once()

	err := svc.DeleteIndexByID(ctx, indexID)
	assert.Error(t, err)
	appErr, ok := err.(*ferrors.AppError)
	require.True(t, ok)
	assert.Equal(t, ferrors.ErrCodeInternalError, appErr.Code)
	assert.Contains(t, appErr.Message, "failed to delete index")
	assert.Equal(t, repoErr, appErr.Unwrap())
	assert.Contains(t, mockLog.Logs[len(mockLog.Logs)-1], "ERROR: Failed to delete index")

	mockRepo.AssertExpectations(t)
}
